#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: 6e18879b-ba1f-4bd1-b2a7-848b352f0f6c
# Source File: G:\My Drive\DSS Software and Systems Team\PowerShell Studio Projects\HelpDesk Tool\HelpDesk Tool.psproj
#------------------------------------------------------------------------
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2020 v5.7.174
     Generated on:       5/8/2020 12:04 PM
     Generated by:       THOWC35460
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2020
#>



#region Source: Startup.pss
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main {
<#
    .SYNOPSIS
        The Main function starts the project application.
    
    .PARAMETER Commandline
        $Commandline contains the complete argument string passed to the script packager executable.
    
    .NOTES
        Use this function to initialize your script and to call GUI forms.
		
    .NOTES
        To get the console output in the Packager (Forms Engine) use: 
		$ConsoleOutput (Type: System.Collections.ArrayList)
#>
	Param ([String]$Commandline)
		
	#--------------------------------------------------------------------------
	#TODO: Add initialization script here (Load modules and check requirements)
	$credential = Get-Credential
	Connect-MC1 
	
	#--------------------------------------------------------------------------
	
	if((Show-MainForm_psf) -eq 'OK')
	{
		
	}
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}


#endregion Source: Startup.pss

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	#$global:tagnumber = $txtBoxTag.Text
	#$global:devicename = $txtBoxTag.Text
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($null -ne $hostinvocation)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	
	function Write-Status
	{
		[CmdletBinding()]
		param
		(
			[Parameter(Mandatory)]
			[ValidateNotNullOrEmpty()]
			[string]$Message
		)
		$statusBar1.Text = $Message
	}
	
	function Connect-MC1
	{
		[CmdletBinding()]
		[Alias()]
		[OutputType([int])]
		Param
		(dfgds;o'jglsadfjgois dfglksdfg
			# Param1 help description
			[Parameter(Mandatory = $false,
					   ValueFromPipelineByPropertyName = $true,
					   Position = 0)]
			$Param1,
			# Param2 help description
	
			[int]$Param2
		)
		
		
		# This script was auto-generated at '4/18/2020 4:07:48 PM'.
		
		#Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process
		
		# Site configuration
		$SiteCode = "MC1" # Site code 
		$ProviderMachineName = "SDCM01.ad.mc.local" # SMS Provider machine name
		
		# Customizations
		$initParams = @{ }
		#$initParams.Add("Verbose", $true) # Uncomment this line to enable verbose logging
		#$initParams.Add("ErrorAction", "Stop") # Uncomment this line to stop the script on any errors
		
		# Do not change anything below this line
		
		# Import the ConfigurationManager.psd1 module 
		if ((Get-Module ConfigurationManager) -eq $null)
		{
			Import-Module "$($ENV:SMS_ADMIN_UI_PATH)\..\ConfigurationManager.psd1" @initParams
		}
		
		# Connect to the site's drive if it is not already present
		if ((Get-PSDrive -Name $SiteCode -PSProvider CMSite -ErrorAction SilentlyContinue) -eq $null)
		{
			New-PSDrive -Name $SiteCode -PSProvider CMSite -Root $ProviderMachineName @initParams
		}
		
		# Set the current location to be the site code.
		Set-Location "$($SiteCode):\" @initParams
	}
	
	Function Start-CMClientAction
	{
		[cmdletbinding()]
		Param
		(
			[Parameter(ValueFromPipeline = $True,
					   ValueFromPipelineByPropertyName = $True,
					   HelpMessage = 'Enter the name of either one or more computers')]
			[Alias('CN')]
			$ComputerName = $env:COMPUTERNAME,
			[Parameter(ParameterSetName = 'Set 1',
					   HelpMessage = 'Enter the SCCM client action numerical value')]
			[ValidateNotNullOrEmpty()]
			[ValidateRange(1, 49)]
			[Alias('SCA')]
			[Int]$SCCMClientAction,
			[Parameter(ParameterSetName = 'Set 2',
					   HelpMessage = 'Use this switch parameter to run the following 3 SCCM client actions: Machine Policy Retrieval & Evaluation Cycle, Software Updates Scan Cycle, and Software Updates Deployment Evaluation Cycle')]
			[Alias('SMB')]
			[Switch]$SCCMMachineBundle,
			[Parameter(ParameterSetName = 'Set 3',
					   HelpMessage = 'Use this switch parameter to run the following 3 SCCM client actions: Machine Policy Retrieval & Evaluation Cycle, Software Updates Scan Cycle, and Software Updates Deployment Evaluation Cycle')]
			[Alias('SAB')]
			[Switch]$SCCMActionsBundle,
			[Parameter(ParameterSetName = 'Set 4',
					   HelpMessage = 'Use this switch parameter to run the following 3 SCCM client actions: Machine Policy Retrieval & Evaluation Cycle, Software Updates Scan Cycle, and Software Updates Deployment Evaluation Cycle')]
			[Alias('SSA')]
			[Switch]$SCCMSoftwareAction
			
		)
		
		Begin
		{
			$NewLine = "`r`n"
			
			If ($ComputerName -eq $env:COMPUTERNAME)
			{
				$ComputerVar = $ComputerName.ToUpper()
			}
			
		}
		
		Process
		{
			Switch ($SCCMSoftwareAction)
			{
				'1' { $ClientAction = '{00000000-0000-0000-0000-000000000001}' }
				
			}
			
			If ($PSBoundParameters.Keys.Contains('SCCMActionsBundle'))
			{
				Foreach ($Computer in $ComputerVar)
				{
					Write-Output -Verbose '---------- Running Full SCCM Actions Bundle ----------'
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '========================'
						Write-Output -Verbose 'Hardware Inventory Cycle'
						Write-Output -Verbose '========================'
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000001}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Hardware Inventory Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '==============================='
						Write-Output -Verbose 'Discovery Data Collection Cycle'
						Write-Output -Verbose '==============================='
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000003}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Discovery Data Collection Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '==========================================='
						Write-Output -Verbose 'Machine Policy Retrieval & Evaluation Cycle'
						Write-Output -Verbose '==========================================='
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000021}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Machine Policy Retrieval and Evaluation Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '==========================='
						Write-Output -Verbose 'Software Updates Scan Cycle'
						Write-Output -Verbose '==========================='
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000113}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Software Updates Scan Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '======================================='
						Write-Output -Verbose 'Application Deployment Evaluation Cycle'
						Write-Output -Verbose '======================================='
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000121}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Application Deployment Evaluation Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '========================'
						Write-Output -Verbose 'Software Inventory Cycle'
						Write-Output -Verbose '========================'
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000002}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Software Inventory Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '============================================'
						Write-Output -Verbose 'Software Updates Deployment Evaluation Cycle'
						Write-Output -Verbose '============================================'
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000108}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Software Updates Deployment Evaluation Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
				}
			}
			elseif ($PSBoundParameters.Keys.Contains('SCCMMachineBundle'))
			{
				Foreach ($Computer in $ComputerVar)
				{
					Write-Output -Verbose '---------- Running SCCM Machine Actions Bundle ----------'
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '========================'
						Write-Output -Verbose 'Hardware Inventory Cycle'
						Write-Output -Verbose '========================'
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000001}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Hardware Inventory Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '==============================='
						Write-Output -Verbose 'Discovery Data Collection Cycle'
						Write-Output -Verbose '==============================='
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000003}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Discovery Data Collection Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '==========================================='
						Write-Output -Verbose 'Machine Policy Retrieval & Evaluation Cycle'
						Write-Output -Verbose '==========================================='
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000021}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Machine Policy Retrieval and Evaluation Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
				}
			}
			elseif ($PSBoundParameters.Keys.Contains('SCCMSoftwareAction'))
			{
				Foreach ($Computer in $ComputerVar)
				{
					Write-Output -Verbose '---------- Running SCCM Client Actions Bundle ----------'
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '==========================='
						Write-Output -Verbose 'Software Updates Scan Cycle'
						Write-Output -Verbose '==========================='
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000113}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Software Updates Scan Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '======================================='
						Write-Output -Verbose 'Application Deployment Evaluation Cycle'
						Write-Output -Verbose '======================================='
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000121}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Application Deployment Evaluation Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '========================'
						Write-Output -Verbose 'Software Inventory Cycle'
						Write-Output -Verbose '========================'
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000002}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Software Inventory Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
					
					Try
					{
						$NewLine
						
						Write-Output -Verbose '============================================'
						Write-Output -Verbose 'Software Updates Deployment Evaluation Cycle'
						Write-Output -Verbose '============================================'
						
						$NewLine
						
						Invoke-WmiMethod -ComputerName $Computer -Namespace root\ccm -Class sms_client -Name TriggerSchedule -ArgumentList '{00000000-0000-0000-0000-000000000108}' -ErrorAction Stop
						
						$NewLine
						
						Write-Output -Verbose 'Software Updates Deployment Evaluation Cycle action successfully initiated'
						
						$NewLine
						
						Write-Output -Verbose 'Waiting 30 Second before running next SCCM client action...'
						
						Start-Sleep -Seconds 30
						
						$NewLine
					}
					
					Catch
					{
						$NewLine
						
						Write-Warning -Message "The following error occurred when trying to run the specified SCCM client action on computer ${Computer}: $_"
						
						$Newline
						
						Break
					}
				}
			}
			
		}
		
		End { }
	}
	
	Function Install-RSAT
	{
		
		[CmdletBinding()]
		param (
			[parameter(Mandatory = $false)]
			[ValidateNotNullOrEmpty()]
			[switch]$All,
			[parameter(Mandatory = $false)]
			[ValidateNotNullOrEmpty()]
			[switch]$Basic,
			[parameter(Mandatory = $false)]
			[ValidateNotNullOrEmpty()]
			[switch]$ServerManager,
			[parameter(Mandatory = $false)]
			[ValidateNotNullOrEmpty()]
			[switch]$Uninstall
		)
		
		# Check for administrative rights
		if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator"))
		{
			Write-Warning -Message "The script requires elevation"
			break
		}
		
		# Create Pending Reboot function for registry
		function Test-PendingRebootRegistry
		{
			$CBSRebootKey = Get-ChildItem "HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ErrorAction Ignore
			$WURebootKey = Get-Item "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired" -ErrorAction Ignore
			if (($CBSRebootKey -ne $null) -OR ($WURebootKey -ne $null))
			{
				$true
			}
			else
			{
				$false
			}
		}
		
		# Windows 10 1809 build
		$1809Build = "17763"
		# Windows 10 1903 build
		$1903Build = "18362"
		# Windows 10 1909 build
		$1909Build = "18363"
		# Get running Windows build
		$WindowsBuild = (Get-CimInstance -Class Win32_OperatingSystem).BuildNumber
		# Get information about local WSUS server
		$WUServer = (Get-ItemProperty "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name WUServer -ErrorAction Ignore).WUServer
		#$DualScan = (Get-ItemProperty "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name DisableDualScan -ErrorAction Ignore).DisableDualScan
		$TestPendingRebootRegistry = Test-PendingRebootRegistry
		
		if (($WindowsBuild -eq $1809Build) -OR ($WindowsBuild -eq $1903Build) -OR ($WindowsBuild -eq $1909Build))
		{
			Write-Verbose -Verbose "Running correct Windows 10 build number for installing RSAT with Features on Demand. Build number is: $WindowsBuild"
			Write-Verbose -Verbose "***********************************************************"
			
			if ($WUServer -ne $null)
			{
				Write-Verbose -Verbose "A local WSUS server was found configured by group policy: $WUServer"
				Write-Verbose -Verbose "You might need to configure additional setting by GPO if things are not working"
				Write-Verbose -Verbose "The GPO of interest is following: Specify settings for optional component installation and component repair"
				Write-Verbose -Verbose "Check ON: Download repair content and optional features directly from Windows Update..."
				Write-Verbose -Verbose "***********************************************************"
			}
			
			if ($TestPendingRebootRegistry -eq "True")
			{
				Write-Verbose -Verbose "Reboots are pending. The script will continue, but RSAT might not install successfully"
				Write-Verbose -Verbose "***********************************************************"
			}
			
			if ($PSBoundParameters["All"])
			{
				Write-Verbose -Verbose "Script is running with -All parameter. Installing all available RSAT features"
				$Install = Get-WindowsCapability -Online | Where-Object { $_.Name -like "Rsat*" -AND $_.State -eq "NotPresent" }
				if ($Install -ne $null)
				{
					$currentWU = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "UseWUServer" | select -ExpandProperty UseWUServer
					Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "UseWUServer" -Value 0
					Restart-Service wuauserv
					
					foreach ($Item in $Install)
					{
						$RsatItem = $Item.Name
						Write-Verbose -Verbose "Adding $RsatItem to Windows"
						try
						{
							Add-WindowsCapability -Online -Name $RsatItem
						}
						catch [System.Exception]
						{
							Write-Verbose -Verbose "Failed to add $RsatItem to Windows"
							Write-Warning -Message $_.Exception.Message
						}
					}
					
					Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name "UseWUServer" -Value $currentWU
					Restart-Service wuauserv
				}
				else
				{
					Write-Verbose -Verbose "All RSAT features seems to be installed already"
				}
			}
			
			if ($PSBoundParameters["Basic"])
			{
				Write-Verbose -Verbose "Script is running with -Basic parameter. Installing basic RSAT features"
				# Querying for what I see as the basic features of RSAT. Modify this if you think something is missing. :-)
				$Install = Get-WindowsCapability -Online | Where-Object { $_.Name -like "Rsat.ActiveDirectory*" -OR $_.Name -like "Rsat.DHCP.Tools*" -OR $_.Name -like "Rsat.Dns.Tools*" -OR $_.Name -like "Rsat.GroupPolicy*" -OR $_.Name -like "Rsat.ServerManager*" -AND $_.State -eq "NotPresent" }
				if ($Install -ne $null)
				{
					foreach ($Item in $Install)
					{
						$RsatItem = $Item.Name
						Write-Verbose -Verbose "Adding $RsatItem to Windows"
						try
						{
							Add-WindowsCapability -Online -Name $RsatItem
						}
						catch [System.Exception]
						{
							Write-Verbose -Verbose "Failed to add $RsatItem to Windows"
							Write-Warning -Message $_.Exception.Message
						}
					}
				}
				else
				{
					Write-Verbose -Verbose "The basic features of RSAT seems to be installed already"
				}
			}
			
			if ($PSBoundParameters["ServerManager"])
			{
				Write-Verbose -Verbose "Script is running with -ServerManager parameter. Installing Server Manager RSAT feature"
				$Install = Get-WindowsCapability -Online | Where-Object { $_.Name -like "Rsat.ServerManager*" -AND $_.State -eq "NotPresent" }
				if ($Install -ne $null)
				{
					$RsatItem = $Install.Name
					Write-Verbose -Verbose "Adding $RsatItem to Windows"
					try
					{
						Add-WindowsCapability -Online -Name $RsatItem
					}
					catch [System.Exception]
					{
						Write-Verbose -Verbose "Failed to add $RsatItem to Windows"
						Write-Warning -Message $_.Exception.Message; break
					}
				}
				
				else
				{
					Write-Verbose -Verbose "$RsatItem seems to be installed already"
				}
			}
			
			if ($PSBoundParameters["Uninstall"])
			{
				Write-Verbose -Verbose "Script is running with -Uninstall parameter. Uninstalling all RSAT features"
				# Querying for installed RSAT features first time
				$Installed = Get-WindowsCapability -Online | Where-Object { $_.Name -like "Rsat*" -AND $_.State -eq "Installed" -AND $_.Name -notlike "Rsat.ServerManager*" -AND $_.Name -notlike "Rsat.GroupPolicy*" -AND $_.Name -notlike "Rsat.ActiveDirectory*" }
				if ($Installed -ne $null)
				{
					Write-Verbose -Verbose "Uninstalling the first round of RSAT features"
					# Uninstalling first round of RSAT features - some features seems to be locked until others are uninstalled first
					foreach ($Item in $Installed)
					{
						$RsatItem = $Item.Name
						Write-Verbose -Verbose "Uninstalling $RsatItem from Windows"
						try
						{
							Remove-WindowsCapability -Name $RsatItem -Online
						}
						catch [System.Exception]
						{
							Write-Verbose -Verbose "Failed to uninstall $RsatItem from Windows"
							Write-Warning -Message $_.Exception.Message
						}
					}
				}
				# Querying for installed RSAT features second time
				$Installed = Get-WindowsCapability -Online | Where-Object { $_.Name -like "Rsat*" -AND $_.State -eq "Installed" }
				if ($Installed -ne $null)
				{
					Write-Verbose -Verbose "Uninstalling the second round of RSAT features"
					# Uninstalling second round of RSAT features
					foreach ($Item in $Installed)
					{
						$RsatItem = $Item.Name
						Write-Verbose -Verbose "Uninstalling $RsatItem from Windows"
						try
						{
							Remove-WindowsCapability -Name $RsatItem -Online
						}
						catch [System.Exception]
						{
							Write-Verbose -Verbose "Failed to remove $RsatItem from Windows"
							Write-Warning -Message $_.Exception.Message
						}
					}
				}
				else
				{
					Write-Verbose -Verbose "All RSAT features seems to be uninstalled already"
				}
			}
		}
		else
		{
			Write-Warning -Message "Not running correct Windows 10 build: $WindowsBuild"
			
		}
	}
	
	
#endregion Source: Globals.ps1

#region Source: MainForm.psf
function Show-MainForm_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$formHelpDeskTool = New-Object 'System.Windows.Forms.Form'
	$groupbox4 = New-Object 'System.Windows.Forms.GroupBox'
	$buttonRemote = New-Object 'System.Windows.Forms.Button'
	$buttonClearCache = New-Object 'System.Windows.Forms.Button'
	$buttonRunActions = New-Object 'System.Windows.Forms.Button'
	$groupbox3 = New-Object 'System.Windows.Forms.GroupBox'
	$buttonEnable = New-Object 'System.Windows.Forms.Button'
	$buttonDisable = New-Object 'System.Windows.Forms.Button'
	$groupbox2 = New-Object 'System.Windows.Forms.GroupBox'
	$datagridview1 = New-Object 'System.Windows.Forms.DataGridView'
	$groupbox1 = New-Object 'System.Windows.Forms.GroupBox'
	$textbox1 = New-Object 'System.Windows.Forms.TextBox'
	$SCCMCol = New-Object 'System.Windows.Forms.Label'
	$AD = New-Object 'System.Windows.Forms.Label'
	$txtADLoc = New-Object 'System.Windows.Forms.TextBox'
	$buttonChange = New-Object 'System.Windows.Forms.Button'
	$txtBoxTag = New-Object 'System.Windows.Forms.TextBox'
	$labelTagNumber = New-Object 'System.Windows.Forms.Label'
	$statusbar1 = New-Object 'System.Windows.Forms.StatusBar'
	$menustrip1 = New-Object 'System.Windows.Forms.MenuStrip'
	$fileToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$exitToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$toolsToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$rSATToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	$formHelpDeskTool_Load={
		#TODO: Initialize Form Controls here
		
	}
	
	$exitToolStripMenuItem_Click={
		#TODO: Place custom script here
		$formHelpDeskTool.close()
	}
	
	
	$buttonChange_Click = {
		
		if ($buttonChange.Text -eq "Find it Now")
		{
			try
			{
				if (-not $txtBoxTag.Text) ## If the Connect text box is empty
				{
					## Rather than simply displaying the connection error in the status bar like all the other errors, you can choose
					## to be more obvious and display a message box. I use message boxes to display more critical errors that will affect
					## the entire tool as a whole.
					[System.Windows.Forms.MessageBox]::Show('No computer specified for connection', 'Invalid input', 0, 16)
					Write-Status -Message "Enter Tag Number..."
					throw 'No computer specified for connection'
				}
				else
				{
					## $tagnumber and $devicename must be global because they be referenced in various functions that will not be in the
					## same scope as the scriptblock we're in now.
					$global:tagnumber = $txtBoxTag.Text
					$getdevicename = Get-CMDevice -Name "*$tagnumber*" | select name
					$global:devicename = $getdevicename.name
				}
							
				Write-Status -Message "Checking for Device HostName..."
				Start-Sleep -Milliseconds 500
				## Test to find HostName of computer in SCCM
				if (-not $devicename)
				{
					throw 'Device does not exist.'
				}
				else
				{
					$txtBoxTag.Text = $devicename																		#Sets the captured devicename in the text box
					$buttonChange.Text = 'Connect' 																		# Change the text in the label.
					$adloc = Get-ADComputer -Identity "$devicename" -Properties CanonicalName | select CanonicalName	#Finds the ADOU of the Device
					$txtADLoc.Text = $adloc.CanonicalName -replace "ad.mc.local/MCC/"									#Sets the AD text box with the AD OU cuts base of OU
					Write-Status -Message "Device found Click Connect"
				}
			}
			catch
			{
				Write-Status -Message $_.Exception.Message
			}
		}
		elseif ($buttonChange.Text -eq "Connect")
		{
			try
			{
				Write-Status -Message "Testing connectivity..."
				## Test to ensure the remote client can be pinged
				if (-not (Test-Connection -ComputerName "$devicename" -Count 1 -Quiet))
				{
					$buttonChange.Text = 'Find it Now'
					$txtBoxTag.Text = ""
					throw 'Computer is offline or does not exist.'
				}
				else {
					## The throw command is typically used for error handling. However, in a GUI, it can also be a great way to simply
					## act as status messaging as well.
					$buttonChange.Text = 'Disconnect' # Change the text in the label.
					throw "Connected to $devicename"
				}
			}
			catch
			{
				Write-Status -Message $_.Exception.Message
			}
		}
		elseif ($buttonChange.Text -eq "Disconnect")
		{
			Try
			{
				$txtBoxTag.Text = ""
				Write-Status -Message "Disconnecting"
				Start-Sleep -Seconds "3"
				$buttonChange.Text = "Find it Now"
				Write-Status -Message "Enter Tag Number"
			}
			catch
			{
				Write-Status -Message $_.Exception.Message
			}
		}
	}
	
	$txtBoxTag_TextChanged={
		#TODO: Place custom script here
			
	}
	
	$txtBoxTag_KeyDown = [System.Windows.Forms.KeyEventHandler]
	{
		#Event Argument: $_ = [System.Windows.Forms.KeyEventArgs]
		if ($_.KeyCode -eq 'Enter')
		{
			&$buttonChange_Click
		}
	}
	$buttonRunActions_Click={
		#TODO: Place custom script here
		if ($result -ne $null)
		{
			if ($result -eq [System.Windows.Forms.DialogResult]::OK)
			{
				$x = $listBox.SelectedItem
				If ($x -eq "Update Software Actions")
				{
					Start-CMClientAction -SCCMSoftwareAction
				}
				elseif ($x -eq "Update All Policies (Note: May take over an hour)")
				{
					Start-CMClientAction -SCCMActionsBundle
				}
				elseif ($x -eq "Update Machine Actions")
				{
					Start-CMClientAction -SCCMMachineBundle
				}
			}
		}
		else { }
	}
	
	$txtADLoc_TextChanged={
		#TODO: Place custom script here
	
	}
	
	$rSATToolStripMenuItem_Click={
		#TODO: Place custom script here
		Install-Rsat -all
	}
	
	#region Control Helper Functions
	function Update-DataGridView
	{
		<#
		.SYNOPSIS
			This functions helps you load items into a DataGridView.
	
		.DESCRIPTION
			Use this function to dynamically load items into the DataGridView control.
	
		.PARAMETER  DataGridView
			The DataGridView control you want to add items to.
	
		.PARAMETER  Item
			The object or objects you wish to load into the DataGridView's items collection.
		
		.PARAMETER  DataMember
			Sets the name of the list or table in the data source for which the DataGridView is displaying data.
	
		.PARAMETER AutoSizeColumns
		    Resizes DataGridView control's columns after loading the items.
		#>
		Param (
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			[System.Windows.Forms.DataGridView]$DataGridView,
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			$Item,
		    [Parameter(Mandatory=$false)]
			[string]$DataMember,
			[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
		)
		$DataGridView.SuspendLayout()
		$DataGridView.DataMember = $DataMember
		
		if ($null -eq $Item)
		{
			$DataGridView.DataSource = $null
		}
		elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
		{
			$DataGridView.DataSource = $Item.Tables[0]
		}
		elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
		{
			$DataGridView.DataSource = $Item
		}
		else
		{
			$array = New-Object System.Collections.ArrayList
			
			if ($Item -is [System.Collections.IList])
			{
				$array.AddRange($Item)
			}
			else
			{
				$array.Add($Item)
			}
			$DataGridView.DataSource = $array
		}
		
		if ($AutoSizeColumns -ne 'None')
		{
			$DataGridView.AutoResizeColumns($AutoSizeColumns)
		}
		
		$DataGridView.ResumeLayout()
	}
	
	
	
	function ConvertTo-DataTable
	{
		<#
			.SYNOPSIS
				Converts objects into a DataTable.
		
			.DESCRIPTION
				Converts objects into a DataTable, which are used for DataBinding.
		
			.PARAMETER  InputObject
				The input to convert into a DataTable.
		
			.PARAMETER  Table
				The DataTable you wish to load the input into.
		
			.PARAMETER RetainColumns
				This switch tells the function to keep the DataTable's existing columns.
			
			.PARAMETER FilterWMIProperties
				This switch removes WMI properties that start with an underline.
		
			.EXAMPLE
				$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
		#>
		[OutputType([System.Data.DataTable])]
		param(
		$InputObject, 
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterWMIProperties)
		
		if($null -eq $Table)
		{
			$Table = New-Object System.Data.DataTable
		}
		
		if ($null -eq $InputObject)
		{
			$Table.Clear()
			return @( ,$Table)
		}
		
		if ($InputObject -is [System.Data.DataTable])
		{
			$Table = $InputObject
		}
		elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
		{
			$Table = $InputObject.Tables[0]
		}
		else
		{
			if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
			{
				#Clear out the Table Contents
				$Table.Clear()
				
				if ($null -eq $InputObject) { return } #Empty Data
				
				$object = $null
				#find the first non null value
				foreach ($item in $InputObject)
				{
					if ($null -ne $item)
					{
						$object = $item
						break
					}
				}
				
				if ($null -eq $object) { return } #All null then empty
				
				#Get all the properties in order to create the columns
				foreach ($prop in $object.PSObject.Get_Properties())
				{
					if (-not $FilterWMIProperties -or -not $prop.Name.StartsWith('__')) #filter out WMI properties
					{
						#Get the type from the Definition string
						$type = $null
						
						if ($null -ne $prop.Value)
						{
							try { $type = $prop.Value.GetType() }
							catch { Out-Null }
						}
						
						if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
						{
							[void]$table.Columns.Add($prop.Name, $type)
						}
						else #Type info not found
						{
							[void]$table.Columns.Add($prop.Name)
						}
					}
				}
				
				if ($object -is [System.Data.DataRow])
				{
					foreach ($item in $InputObject)
					{
						$Table.Rows.Add($item)
					}
					return @( ,$Table)
				}
			}
			else
			{
				$Table.Rows.Clear()
			}
			
			foreach ($item in $InputObject)
			{
				$row = $table.NewRow()
				
				if ($item)
				{
					foreach ($prop in $item.PSObject.Get_Properties())
					{
						if ($table.Columns.Contains($prop.Name))
						{
							$row.Item($prop.Name) = $prop.Value
						}
					}
				}
				[void]$table.Rows.Add($row)
			}
		}
		
		return @(,$Table)
	}
	
	
	#endregion
	
	$buttonClearCache_Click={
		#TODO: Place custom script here
		
	}
	
	$buttonDisable_Click={
		#TODO: Place custom script here
		
	}
	
	$buttonEnable_Click={
		#TODO: Place custom script here
		
	}
	
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$formHelpDeskTool.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:MainForm_datagridview1 = $datagridview1.SelectedCells
		if ($datagridview1.SelectionMode -eq 'FullRowSelect')
		{ $script:MainForm_datagridview1_SelectedObjects = $datagridview1.SelectedRows | Select-Object -ExpandProperty DataBoundItem }
		else { $script:MainForm_datagridview1_SelectedObjects = $datagridview1.SelectedCells | Select-Object -ExpandProperty RowIndex -Unique | ForEach-Object { if ($_ -ne -1) { $datagridview1.Rows[$_].DataBoundItem } } }
		$script:MainForm_textbox1 = $textbox1.Text
		$script:MainForm_txtADLoc = $txtADLoc.Text
		$script:MainForm_txtBoxTag = $txtBoxTag.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$buttonClearCache.remove_Click($buttonClearCache_Click)
			$buttonRunActions.remove_Click($buttonRunActions_Click)
			$buttonEnable.remove_Click($buttonEnable_Click)
			$buttonDisable.remove_Click($buttonDisable_Click)
			$txtADLoc.remove_TextChanged($txtADLoc_TextChanged)
			$buttonChange.remove_Click($buttonChange_Click)
			$txtBoxTag.remove_TextChanged($txtBoxTag_TextChanged)
			$formHelpDeskTool.remove_Load($formHelpDeskTool_Load)
			$exitToolStripMenuItem.remove_Click($exitToolStripMenuItem_Click)
			$rSATToolStripMenuItem.remove_Click($rSATToolStripMenuItem_Click)
			$formHelpDeskTool.remove_Load($Form_StateCorrection_Load)
			$formHelpDeskTool.remove_Closing($Form_StoreValues_Closing)
			$formHelpDeskTool.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch { Out-Null <# Prevent PSScriptAnalyzer warning #> }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$formHelpDeskTool.SuspendLayout()
	$groupbox2.SuspendLayout()
	$groupbox1.SuspendLayout()
	$menustrip1.SuspendLayout()
	$groupbox3.SuspendLayout()
	$groupbox4.SuspendLayout()
	#
	# formHelpDeskTool
	#
	$formHelpDeskTool.Controls.Add($groupbox4)
	$formHelpDeskTool.Controls.Add($groupbox3)
	$formHelpDeskTool.Controls.Add($groupbox2)
	$formHelpDeskTool.Controls.Add($groupbox1)
	$formHelpDeskTool.Controls.Add($statusbar1)
	$formHelpDeskTool.Controls.Add($menustrip1)
	$formHelpDeskTool.AutoScaleDimensions = '6, 13'
	$formHelpDeskTool.AutoScaleMode = 'Font'
	$formHelpDeskTool.ClientSize = '1224, 498'
	$formHelpDeskTool.MainMenuStrip = $menustrip1
	$formHelpDeskTool.Name = 'formHelpDeskTool'
	$formHelpDeskTool.Text = 'HelpDesk Tool'
	$formHelpDeskTool.add_Load($formHelpDeskTool_Load)
	#
	# groupbox4
	#
	$groupbox4.Controls.Add($buttonRemote)
	$groupbox4.Controls.Add($buttonClearCache)
	$groupbox4.Controls.Add($buttonRunActions)
	$groupbox4.Location = '1113, 41'
	$groupbox4.Name = 'groupbox4'
	$groupbox4.Size = '98, 115'
	$groupbox4.TabIndex = 13
	$groupbox4.TabStop = $False
	$groupbox4.Text = 'SCCM'
	$groupbox4.UseCompatibleTextRendering = $True
	#
	# buttonRemote
	#
	$buttonRemote.Location = '10, 77'
	$buttonRemote.Name = 'buttonRemote'
	$buttonRemote.Size = '79, 23'
	$buttonRemote.TabIndex = 10
	$buttonRemote.Text = 'Remote'
	$buttonRemote.UseCompatibleTextRendering = $True
	$buttonRemote.UseVisualStyleBackColor = $True
	#
	# buttonClearCache
	#
	$buttonClearCache.Location = '10, 48'
	$buttonClearCache.Name = 'buttonClearCache'
	$buttonClearCache.Size = '79, 23'
	$buttonClearCache.TabIndex = 9
	$buttonClearCache.Text = 'Clear Cache'
	$buttonClearCache.UseCompatibleTextRendering = $True
	$buttonClearCache.UseVisualStyleBackColor = $True
	$buttonClearCache.add_Click($buttonClearCache_Click)
	#
	# buttonRunActions
	#
	$buttonRunActions.CausesValidation = $False
	$buttonRunActions.Location = '10, 19'
	$buttonRunActions.Name = 'buttonRunActions'
	$buttonRunActions.Size = '79, 23'
	$buttonRunActions.TabIndex = 5
	$buttonRunActions.Text = 'Run Actions'
	$buttonRunActions.UseCompatibleTextRendering = $True
	$buttonRunActions.UseVisualStyleBackColor = $True
	$buttonRunActions.add_Click($buttonRunActions_Click)
	#
	# groupbox3
	#
	$groupbox3.Controls.Add($buttonEnable)
	$groupbox3.Controls.Add($buttonDisable)
	$groupbox3.Location = '1113, 232'
	$groupbox3.Name = 'groupbox3'
	$groupbox3.Size = '99, 80'
	$groupbox3.TabIndex = 12
	$groupbox3.TabStop = $False
	$groupbox3.Text = 'Deep Freeze'
	$groupbox3.UseCompatibleTextRendering = $True
	#
	# buttonEnable
	#
	$buttonEnable.Location = '14, 48'
	$buttonEnable.Name = 'buttonEnable'
	$buttonEnable.Size = '75, 23'
	$buttonEnable.TabIndex = 11
	$buttonEnable.Text = 'Enable'
	$buttonEnable.UseCompatibleTextRendering = $True
	$buttonEnable.UseVisualStyleBackColor = $True
	$buttonEnable.add_Click($buttonEnable_Click)
	#
	# buttonDisable
	#
	$buttonDisable.Location = '14, 19'
	$buttonDisable.Name = 'buttonDisable'
	$buttonDisable.Size = '75, 23'
	$buttonDisable.TabIndex = 10
	$buttonDisable.Text = 'Disable'
	$buttonDisable.UseCompatibleTextRendering = $True
	$buttonDisable.UseVisualStyleBackColor = $True
	$buttonDisable.add_Click($buttonDisable_Click)
	#
	# groupbox2
	#
	$groupbox2.Controls.Add($datagridview1)
	$groupbox2.Location = '15, 171'
	$groupbox2.Name = 'groupbox2'
	$groupbox2.Size = '372, 299'
	$groupbox2.TabIndex = 8
	$groupbox2.TabStop = $False
	$groupbox2.Text = 'Applications'
	$groupbox2.UseCompatibleTextRendering = $True
	#
	# datagridview1
	#
	$datagridview1.ColumnHeadersHeightSizeMode = 'AutoSize'
	$datagridview1.Dock = 'Fill'
	$datagridview1.Location = '3, 16'
	$datagridview1.Name = 'datagridview1'
	$datagridview1.Size = '366, 280'
	$datagridview1.TabIndex = 0
	#
	# groupbox1
	#
	$groupbox1.Controls.Add($textbox1)
	$groupbox1.Controls.Add($SCCMCol)
	$groupbox1.Controls.Add($AD)
	$groupbox1.Controls.Add($txtADLoc)
	$groupbox1.Controls.Add($buttonChange)
	$groupbox1.Controls.Add($txtBoxTag)
	$groupbox1.Controls.Add($labelTagNumber)
	$groupbox1.Location = '13, 31'
	$groupbox1.Name = 'groupbox1'
	$groupbox1.Size = '375, 125'
	$groupbox1.TabIndex = 6
	$groupbox1.TabStop = $False
	$groupbox1.Text = 'Device'
	$groupbox1.UseCompatibleTextRendering = $True
	#
	# textbox1
	#
	$textbox1.Location = '107, 89'
	$textbox1.Name = 'textbox1'
	$textbox1.Size = '246, 20'
	$textbox1.TabIndex = 8
	#
	# SCCMCol
	#
	$SCCMCol.AutoSize = $True
	$SCCMCol.Location = '15, 92'
	$SCCMCol.Name = 'SCCMCol'
	$SCCMCol.Size = '90, 17'
	$SCCMCol.TabIndex = 7
	$SCCMCol.Text = 'SCCM Collection'
	$SCCMCol.UseCompatibleTextRendering = $True
	#
	# AD
	#
	$AD.AutoSize = $True
	$AD.Location = '15, 57'
	$AD.Name = 'AD'
	$AD.Size = '40, 17'
	$AD.TabIndex = 6
	$AD.Text = 'AD OU'
	$AD.UseCompatibleTextRendering = $True
	#
	# txtADLoc
	#
	$txtADLoc.Location = '107, 54'
	$txtADLoc.Name = 'txtADLoc'
	$txtADLoc.Size = '246, 20'
	$txtADLoc.TabIndex = 5
	$txtADLoc.add_TextChanged($txtADLoc_TextChanged)
	#
	# buttonChange
	#
	$buttonChange.BackColor = 'Control'
	$buttonChange.FlatStyle = 'Popup'
	$buttonChange.Location = '278, 22'
	$buttonChange.Name = 'buttonChange'
	$buttonChange.Size = '75, 23'
	$buttonChange.TabIndex = 4
	$buttonChange.Text = 'Find it Now'
	$buttonChange.UseCompatibleTextRendering = $True
	$buttonChange.UseVisualStyleBackColor = $False
	$buttonChange.add_Click($buttonChange_Click)
	#
	# txtBoxTag
	#
	$txtBoxTag.Location = '107, 24'
	$txtBoxTag.Name = 'txtBoxTag'
	$txtBoxTag.Size = '165, 20'
	$txtBoxTag.TabIndex = 3
	$txtBoxTag.add_TextChanged($txtBoxTag_TextChanged)
	#
	# labelTagNumber
	#
	$labelTagNumber.AutoSize = $True
	$labelTagNumber.Location = '15, 27'
	$labelTagNumber.Name = 'labelTagNumber'
	$labelTagNumber.Size = '67, 17'
	$labelTagNumber.TabIndex = 2
	$labelTagNumber.Text = 'Tag Number'
	$labelTagNumber.UseCompatibleTextRendering = $True
	#
	# statusbar1
	#
	$statusbar1.Location = '0, 476'
	$statusbar1.Name = 'statusbar1'
	$statusbar1.Size = '1224, 22'
	$statusbar1.TabIndex = 1
	$statusbar1.Text = 'HelpDesk Tool'
	#
	# menustrip1
	#
	[void]$menustrip1.Items.Add($fileToolStripMenuItem)
	[void]$menustrip1.Items.Add($toolsToolStripMenuItem)
	$menustrip1.Location = '0, 0'
	$menustrip1.Name = 'menustrip1'
	$menustrip1.Size = '1224, 24'
	$menustrip1.TabIndex = 0
	$menustrip1.Text = 'menustrip1'
	#
	# fileToolStripMenuItem
	#
	[void]$fileToolStripMenuItem.DropDownItems.Add($exitToolStripMenuItem)
	$fileToolStripMenuItem.Name = 'fileToolStripMenuItem'
	$fileToolStripMenuItem.Size = '37, 20'
	$fileToolStripMenuItem.Text = 'File'
	#
	# exitToolStripMenuItem
	#
	$exitToolStripMenuItem.Name = 'exitToolStripMenuItem'
	$exitToolStripMenuItem.Size = '92, 22'
	$exitToolStripMenuItem.Text = 'Exit'
	$exitToolStripMenuItem.add_Click($exitToolStripMenuItem_Click)
	#
	# toolsToolStripMenuItem
	#
	[void]$toolsToolStripMenuItem.DropDownItems.Add($rSATToolStripMenuItem)
	$toolsToolStripMenuItem.Name = 'toolsToolStripMenuItem'
	$toolsToolStripMenuItem.Size = '47, 20'
	$toolsToolStripMenuItem.Text = 'Tools'
	#
	# rSATToolStripMenuItem
	#
	$rSATToolStripMenuItem.Name = 'rSATToolStripMenuItem'
	$rSATToolStripMenuItem.Size = '101, 22'
	$rSATToolStripMenuItem.Text = 'RSAT'
	$rSATToolStripMenuItem.add_Click($rSATToolStripMenuItem_Click)
	$groupbox4.ResumeLayout()
	$groupbox3.ResumeLayout()
	$menustrip1.ResumeLayout()
	$groupbox1.ResumeLayout()
	$groupbox2.ResumeLayout()
	$formHelpDeskTool.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $formHelpDeskTool.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$formHelpDeskTool.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$formHelpDeskTool.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$formHelpDeskTool.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $formHelpDeskTool.ShowDialog()

}
#endregion Source: MainForm.psf

#Start the application
Main ($CommandLine)
